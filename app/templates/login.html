{% extends "base.html" %}

{% block content %}
	<h1>Sign In</h1>

	<form action="" method='post' novalidate>
		{{ form.hidden_tag() }}
		<p>
			{{ form.username.label }}<br>
			{{ form.username(size=32) }}
			{% for error in form.username.errors %}
			<span style="color: red;">[{{ error }}]</span>
			<!-- try submitting empty form -->
			{% endfor %}
		</p>
		<p>
			{{ form.password.label }}<br>
			{{ form.password(size=32) }}
			{% for error in form.password.errors %}
			<span style="color: red;">[{{ error }}]</span>
			{% endfor %}
		</p>
		<p>{{ form.remember_me() }} {{ form.remember_me.label }}</p>
		<p>{{ form.submit() }}</p>
	</form>
	<p>
		Forgot Your Password?
		<a href="{{ url_for('reset_password_request') }}">Click to Reset It</a>
	</p>
	<p>New User?
		<a href="{{ url_for('register') }}">Click to Register!</a>
	</p>
{% endblock %}


<!--
The method attribute specifies the HTTP request method that should be used when submitting the form to the server. The default is to send it with a GET request, but in almost all cases, using a POST request makes for a better user experience because requests of this type can submit the form data in the body of the request, while GET requests add the form fields to the URL, cluttering the browser address bar.
--><!--
Using novalidate is entirely optional, but for this first form it is important that you set it because this will allow you to test server-side validation later in this chapter.
--><!--
The form.hidden_tag() template argument generates a hidden field that includes a token that is used to protect the form against CSRF attacks. All you need to do to have the form protected is include this hidden field and have the SECRET_KEY variable defined in the Flask configuration. If you take care of these two things, Flask-WTF does the rest for you.
--><!--
The username and password fields in this template take the size as an argument that will be added to the <input> HTML element as an attribute. This is how you can also attach CSS classes or IDs to form fields.
-->
